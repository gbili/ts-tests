// Single Param Callback
interface spc<S = any, T = any>{
    (a: S): T;
}

type curriedCompose = (...fns: ((...args: any[]) => any)[]) => ((...args: any[]) => any);
const compose: curriedCompose = (...fns) => (...args) => fns.reduceRight((res, fn) => [fn.call(null, ...res)], args)[0];
type returnsInput<T = any> = (x: T) => T;
const identity: returnsInput = x => x;
interface resolver<T = any> extends spc<T, void> {};
interface rejecter<T extends Error = Error> extends spc<T, void> {};
type fork = (reject: rejecter, resolve: resolver) => void;

class Task {

    constructor(private fork: fork) {}

    // The simplest Task fork implementation possible: calls the resolver with the `of` parameter `x`
    static of<T>(x: T): Task {
        return new Task((_, resolve) => resolve(x));
    }

    // Returns a taskNew whose fork resolveNew takes fn(resultsThis) as input
    //
    // returns a new task with a `fork` whose resolve is augmented by the fn param. so when
    // the new task's fork is called with some resolve callback param, the resolve will 
    // receive the initial task's resolution output after it has been pre treated by fn
    // 2 tasks are involved:
    // - taskThis
    // - taskNew
    // fn receives resultsThis, so it is allowed to intercept resultsThis
    // then the processed resultsThis (resultsThisFn) are passed to resolveNew
    // Summary: on taskNew.fork: 
    // - we perform taskThis 
    // - we process resultsThis with fn
    // - we receive the output in resolveNew
    map(fn: spc): Task {
        return new Task((reject, resolve) => this.fork(reject, compose(resolve, fn)));
    }

    // Returns a taskNew whose fork is forkThis with a slight difference: resolverThis is replaced by a
    // callback which uses resultsThis to generate task taskFn through fn, and immediately calls the
    // resulting taskFn's fork with resolverNew
    // 
    // chaining definition usually: map(fn).join() Apply fn and return the result with one container layer less
    //
    // the 3 involved tasks are:
    // - taskThis, 
    // - taskNew,
    // - taskFn 
    //
    // Tip: 
    // taskNew === taskThis.chain(fn), and fn(resultsThis) creates taskFn
    // taskNew.fork === taskThis.chain(fn).fork
    // 
    // on chain(fn) this will happen:
    //   we will create taskNew 
    // on taskNew.fork(rejectNew, resolveNew) this will happen:
    //   taskThis.fork(rejectNew, x => fn(x).fork(rejectNew, resolveNew)) will be called
    // which means that taskThis.fork will call (resultsThis) => fn(resultsThis).fork(a, b) upon completion
    // so fn(resultsThis) will return taskFn, which will immediately be called after taskThis.fork has completed
    // once taskFn.fork has completed, it will call resolveNew.
    // Note that taskFn was generated by fn using the resultsThis passed by taskThis upon completion
    //
    // the chain goes:
    //
    // taskNew.fork(rejectNew, resolveNew):
    //   taskThis.fork(rejectNew, ... ) : actually perform taskThis
    //   ... then on taskThis completion
    //   generate taskFn from resultsThis using fn : actually perform fn on resultsThis (fn must return Task)
    //   ... then once taskFn is generated
    //   taskFn.fork(rejectNew, resolveNew) : actually perform taskFn
    //   ... finally taksFn calls resolveNew(resultsFn)
    //
    // In summary on taskNew.fork(rejectNew, resolveNew): 
    // - resultsThis are used to generate taskFn using fn.
    // - Then taskFn is performed: generates resultsFn. 
    // - Finally resultsFn are passed to resolveNew
    // 
    chain(fn: spc<any, Task>): Task {
        return new Task((rejectNew, resolveNew) => this.fork(
            rejectNew, 
            resultsThis => {
                const taskFn = fn(resultsThis);
                return taskFn.fork(rejectNew, resolveNew);
            })
        );
    }

    // Returns a taskNew whose fork is forkThis with a slight difference: resolverThis is replaced by a
    // callback which does identity(resultsThis), and immediately calls the resulting taskFn's fork with
    // resolverNew as a parameter. This implies that resultsThis must be a Task.
    //
    // Pull the content out of the container
    // Contrary to Maybe.join, Task.join will throw a Unhandled TypeError, 'fork' undefined
    // if taskThis does not pass a Task as parameter to resolveThis on completion (aka as resultsThis)
    // this is because, identity will simply forward resultsThis. 
    // And since chain(idneity) will do identity(resultsThis).fork, it will crash
    //
    // So in which cases will join().fork() not result in a crash?
    //
    // Equivalently, in which cases will resultsThis be a Task?
    // When we do a taskThis.map(someTaskGenFunc), someTaskGenFunc will pass its resulting task
    // to resolveNew, aka resultsThis will be a task..
    join(): Task {
        return this.chain(identity);
    }

    // Returns a taskNew whose fork is forkThis with a slight difference: resolverThis is replaced by a
    // callback which uses resultsThis to generate task taskFn through fn, and immediately calls the
    // resulting taskFn's fork with resolverNew
    ap(f: Task) {
        return this.chain((fn: spc) => f.map(fn));
    }
}

